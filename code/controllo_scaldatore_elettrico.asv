% Progetto controllo di un riscaldatore elettrico
% Giacomo Nobili
% Federico Raffoni
% Marco Roca

close all; clear all; clc;

% parametri del sistema
h_R   = 50;          %  coefficiente di convezione tra riscaldatore e aria [W/(m2 C°)]
A_R   = 0.09;        %  area di scambio termico tra riscaldatore e aria [m2]
c_R   = 823.6;       %  calore specifico del riscaldatore [J/(kg C°)]
c_A   = 1010;        %  calore specifico dell'aria [J/(kg C°)]
m_R   = 1.542;       %  massa del riscaldatore [kg];
m_A   = 0.1041;      %  massa dell'aria [kg]
m_A_dot = 0.2;       %  portata massica dell'aria [kg/s].
T_in    = 25;        %  temperatura dell'aria in ingresso (costante) [C°]
K   = 2e-3;          %  coefficiente di variazione della resistenza con la temperatura  [1/C°]
T_R_e   = 200;       %  temperatura del riscaldatore di equilibrio [C°];
T_out_e = 80;        %  temperatura dell'aria in uscita dal riscaldatore di equilibrio [C°]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Punto 1
% Funzione dello stato del sistema
x = @(t,x)[(h_R*A_R)/(m_R*c_R)*x(2)-(h_R*A_R)/(m_R*c_R)*x(1)+1/(m_R*c_R)*(uu/1+K*x(1));
                m_A_dot/m_A*T_in-(m_A_dot/m_A+(h_R*A_R)/(m_A*c_A))*x(2)+(h_R*A_R)/(m_A*c_A)*x(1)];

% Funzione dell'uscita del sistema
y = @(t,x)[0; x(2)];

% Coppia di equilibrio
x_e = [T_R_e; T_out_e];
u_e = (h_R*A_R)*(x_e(1) - x_e(2))*(1 + K*x_e(1));

% Linearizzazione del sistema non lineare nell'equilibrio (x_e, u_e)
% δx˙ = Aδx + Bδu
% Matrice A
A1 = -(h_R*A_R)/(m_R*c_R)-(1/(m_R*c_R)*u_e*K)/(1+K*x_e(1))^2;   % df1/dx1
A2 = (h_R*A_R)/(m_R*c_R);                                       % df1/dx2
A3 = (h_R*A_R)/(m_A*c_A);                                       % df2/dx1
A4 = -m_A_dot/m_A-(h_R*A_R)/(m_A*c_A);                          % df2/dx2

A = [A1 A2; A3 A4];                                             % matrice 2x2

% Matrice B
B1 = (1/(m_R*c_R))/(1+K*x_e(1));                                % df1/du
B2 = 0;                                                         % df2/du

B = [B1; B2];                                                   % matrice 2x1

% δy = Cδx + Dδu, 
% Matrice C
C1 = 0;                                                         % dh/dx1
C2 = 1;                                                         % dh/dx2

C = [C1 C2];                                                    % matrice 1x2

% Matrice D
D = 0;                                                          % dh/du

% Modello
modello = ss(A, B, C, D);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Punto 2
% Funzione di trasferimento G(s) tale che δY (s) = G(s)δU(s)
G = tf(modello);

% Poli di G(s)
p = pole(G);
fprintf("I poli di G:\n");
disp(p);

% Zeri di G(s) (NON NE HA)
z = zero(G);
fprintf("Gli zeri di G:\n");
disp(z);                   

% Poli e zeri nel piano complesso
figure
pzmap(G);

% Diagrammi di Bode della G
figure
bode(G);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Punto 3
% REGOLATORE
% Design del regolatore statico

% Parametri
e_star = 0.001;         % errore a regime massimo
W_star = 50;            % w(t) = W · 1(t) con W <= 50  
D_star = 2;             % d(t) = D · 1(t) con D <= 2

Mf_star = 40;           % margine di fase minimo imposto
S_star = 18;            % sovraelongazione percentuale massima
T_star = 0.3;           % tempo di assestamento alla ϵ% = 1% massimo (s)

A_d = 60;               % attenuazione disturbo in uscita (dB)
omega_d_min = 1e-10;    % limite inferiore range di pulsazioni di d(t), idealmente 0, concretamente 10^-10, altrimenti matlab non riuscirebbe ad arrivare a -infinito 
omega_d_max = 0.1;      % limite superiore range di pulsazioni di d(t)

A_n = 40;               % attenuazione disturbo di misura (dB)
omega_n_min = 1e3;      % limite inferiore range di pulsazioni di n(t)
omega_n_max = 1e6;      % limite superiore range di pulsazioni di n(t)

Mf_min = 100*abs(log(S_star/100))/sqrt(pi^2 + log(S_star/100)^2);   % Mf_min imposto da S_star
Mf_star = max(Mf_min,Mf_star);                                      % Mf_star come massimo tra quello imposto dal progetto e quello imposto da S_star
omega_c_min = 460/Mf_star/T_star;                                   % vincolo sulla omega_c minima dato da Mf_min e T_star


% Guadagno statico minimo imposto dall'errore a regime
mu_error = (W_star+D_star)/e_star;                  % guadagno statico minimo imposto da e_star
mu_s_error = mu_error/abs(evalfr(G,0));             % (guadagno della R_s) = (guadagno minimo imposto da e_star)/(guadagno statico di G nell'origine)

% Guadagno statico minimo imposto dal disturbo in uscita
mu_dist = 10^(A_d/20);                              % guadagno statico minimo imposto dal disturbo -> da dB a forma lineare (formula inversa di 20log10())
mu_s_dist = mu_dist/abs(evalfr(G,1j*omega_d_max));  % (guadagno della R_s) = (guadagno minimo imposto da d(t))/(guadagno statico nella pulsazione più critica -> dove l'ampiezza è minore)

% Vediamo quale vincolo è più forte
mu_s = max(mu_s_error, mu_s_dist);

% Regolatore Statico
R_s = mu_s;

% Sistema esteso
G_estesa = R_s*G;

% solo per visualizzione, pulsazione minima e massima
omega_plot_min = 1e-4;         % idealmente 0, concretamente 10^-4, altrimenti matlab non riuscirebbe ad arrivare a -infinito
omega_plot_max = omega_n_max;

% Mapping specifiche sul diagramma di Bode (modulo)
figure;
hold on;

patch_d_x = [omega_d_min;omega_d_min;omega_d_max; omega_d_max];
patch_d_y = [-200;A_d;A_d;-200];
patch(patch_d_x,patch_d_y,'r','FaceAlpha',0.1);

patch_n_x = [omega_n_min;omega_n_min;omega_n_max; omega_n_max];
patch_n_y = [-A_n;200;200;-A_n];
patch(patch_n_x,patch_n_y,'r','FaceAlpha',0.1);

patch_omega_c_x = [omega_plot_min;omega_plot_min;omega_c_min; omega_c_min];
patch_omega_c_y = [-200;0;0;-200];
patch(patch_omega_c_x,patch_omega_c_y,'r','FaceAlpha',0.1);

margin(G_estesa,{omega_plot_min,omega_plot_max});           % Diagrammi di Bode della G_estesa
grid on; zoom on;

% Mapping specifiche sul diagramma di Bode (fase)

patch_Mf_x = [omega_c_min; omega_c_min; omega_n_min; omega_n_min];
patch_Mf_y = [-270; -180+Mf_star; -180+Mf_star; -270];
patch(patch_Mf_x,patch_Mf_y,'r','FaceAlpha',0.1);

% Design del regolatore dinamico
% Parametri
epsilon = 5;        % margine di sicurezza della fase

omega_c_star = 100;                                                                    %  valore arbitrario > omega_c_min
M_star = 1/abs(evalfr(G_estesa,1j*omega_c_star));
Mf_star = Mf_star + epsilon;                                                           % margine rispetto a Mf_min
phi_star = Mf_star - 180 - rad2deg(angle(evalfr(G_estesa,1j*omega_c_star))) ;

% Rete anticipatrice
% formule di inversione per la rete anticipatrice
tau_anticipatrice       = (M_star - cosd(phi_star))/(omega_c_star*sind(phi_star));
alpha_tau_anticipatrice = (cosd(phi_star) - 1/M_star)/(omega_c_star*sind(phi_star));

% controllo che tau e alpha_tau siano < 0
if min(tau_anticipatrice,alpha_tau_anticipatrice) < 0
    fprintf('Valori negativi\n');
    return;
end

s = tf('s');
R_d_anticipatrice = (1+tau_anticipatrice*s)/(1+alpha_tau_anticipatrice*s); 

R_anticipata = R_d_anticipatrice*R_s;
L_anticipata = R_anticipata*G;
G_estesa_anticipata = R_d_anticipatrice*G_estesa;

% Rete ritardatrice
omega_c_star_new = 60;
alpha_ritardatrice = 1/abs(evalfr(G_estesa_anticipata,1j*omega_c_star_new));
tau_ritardatrice = 1000;

R_d_ritardatrice = (1 + alpha_ritardatrice*tau_ritardatrice*s)/(1 + tau_ritardatrice*s);

figure;
hold on;

patch_d_x = [omega_d_min;omega_d_min;omega_d_max; omega_d_max];
patch_d_y = [-200;A_d;A_d;-200];
patch(patch_d_x,patch_d_y,'r','FaceAlpha',0.1);

patch_n_x = [omega_n_min;omega_n_min;omega_n_max; omega_n_max];
patch_n_y = [-A_n;200;200;-A_n];
patch(patch_n_x,patch_n_y,'r','FaceAlpha',0.1);

patch_omega_c_x = [omega_plot_min;omega_plot_min;omega_c_min; omega_c_min];
patch_omega_c_y = [-200;0;0;-200];
patch(patch_omega_c_x,patch_omega_c_y,'r','FaceAlpha',0.1);

margin(L_anticipata,{omega_plot_min,omega_plot_max});           % Diagrammi di Bode della G_estesa
grid on; zoom on;

% Mapping specifiche sul diagramma di Bode (fase)

patch_Mf_x = [omega_c_min; omega_c_min; omega_n_min; omega_n_min];
patch_Mf_y = [-270; -180+Mf_star; -180+Mf_star; -270];
patch(patch_Mf_x,patch_Mf_y,'r','FaceAlpha',0.1);


R = R_d_ritardatrice*R_d_anticipatrice*R_s;
L = G * R;


figure;
hold on;

patch_d_x = [omega_d_min;omega_d_min;omega_d_max; omega_d_max];
patch_d_y = [-200;A_d;A_d;-200];
patch(patch_d_x,patch_d_y,'r','FaceAlpha',0.1);

patch_n_x = [omega_n_min;omega_n_min;omega_n_max; omega_n_max];
patch_n_y = [-A_n;200;200;-A_n];
patch(patch_n_x,patch_n_y,'r','FaceAlpha',0.1);

patch_omega_c_x = [omega_plot_min;omega_plot_min;omega_c_min; omega_c_min];
patch_omega_c_y = [-200;0;0;-200];
patch(patch_omega_c_x,patch_omega_c_y,'r','FaceAlpha',0.1);

margin(L,{omega_plot_min,omega_plot_max});           % Diagrammi di Bode della G_estesa
grid on; zoom on;

% Mapping specifiche sul diagramma di Bode (fase)

patch_Mf_x = [omega_c_min; omega_c_min; omega_n_min; omega_n_min];
patch_Mf_y = [-270; -180+Mf_star; -180+Mf_star; -270];
patch(patch_Mf_x,patch_Mf_y,'r','FaceAlpha',0.1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Punto 4

%% Check prestazioni in anello chiuso

% Funzione di sensitività complementare
F = L/(1+L);

% Ingresso di riferimento
W = 50;
figure
T_simulation = 2*T_star;
[y_step,t_step] = step(W*F, T_simulation);
plot(t_step,y_step,'b');
grid on, zoom on, hold on;

LV = evalfr(W*F,0);

% vincolo sovraelongazione
patch([0,T_simulation,T_simulation,0],[LV*(1+S_star/100),LV*(1+S_star/100),LV*2,LV*2],'r','FaceAlpha',0.3,'EdgeAlpha',0.5);

% vincolo tempo di assestamento all'1%
patch([T_star,T_simulation,T_simulation,T_star],[LV*(1-0.01),LV*(1-0.01),0,0],'g','FaceAlpha',0.1,'EdgeAlpha',0.5);
patch([T_star,T_simulation,T_simulation,T_star],[LV*(1+0.01),LV*(1+0.01),LV*2,LV*2],'g','FaceAlpha',0.1,'EdgeAlpha',0.1);

Legend_step = ["Risposta al gradino"; "Vincolo sovraelongazione"; "Vincolo tempo di assestamento"];
legend(Legend_step);

%% Check disturbo in uscita

% Funzione di sensitività
SS = 1/(1+LL);

% Disturbo:
omega_d = 0.02;
d = zeros(size(t));
for k = 1:4
    d = d + 0.8 * sin(0.02 * k * t); 
end

figure






